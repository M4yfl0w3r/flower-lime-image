#!/usr/bin/env python3

import torch
import numpy as np
import matplotlib.pyplot as pyplot

from PIL import Image
from pathlib import Path
from torchvision import transforms

from lime_image import ImageExplainer
from model import CNN


device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

test_image_path = Path('../assets/test_img.jpg')
model_path = Path('../assets/model.pth')

image = Image.open(test_image_path)

model = CNN()
model.load_state_dict(torch.load(str(model_path), map_location = torch.device('cpu')))

preprocess_transform = transforms.Compose([
        transforms.ToTensor(),
        transforms.Normalize(mean = [0.485, 0.456, 0.406], 
                             std = [0.229, 0.224, 0.225])])

image_transform = transforms.Compose([
        transforms.Resize((256, 256)),
        transforms.CenterCrop(224)])

def batch_predict(images: np.ndarray) -> np.ndarray:
    """For each image generated by LIME will return a prediction in the form of 
       a list of probabilities that the image belongs to each class."""

    model.eval()
    batch = torch.stack(tuple(preprocess_transform(i) for i in images), dim = 0)

    for image in images:
        perturbated_images.append(image)

    model.to(device)

    batch  = batch.to(device)
    logits = model(batch)
    probs  = F.softmax(logits, dim=1)

    return probs.detach().cpu().numpy()

explainer = ImageExplainer(np.array(image), batch_predict)
dataset = explainer.generate_dataset(num_samples = 2)

